#!/usr/bin/env python
# begin_generated_IBM_copyright_prolog
#
# This is an automatically generated copyright prolog.
# After initializing,  DO NOT MODIFY OR MOVE
# ================================================================
#
# (C) Copyright IBM Corp.  2010,2011
# Eclipse Public License (EPL)
#
# ================================================================
#
# end_generated_IBM_copyright_prolog

# locale setup
import os
import gettext
curdir = os.path.abspath(os.path.dirname(__file__))
localedir = os.path.join(curdir, '..', 'locale')
t = gettext.translation('messages', localedir, fallback=True)
_ = t.lgettext

import sys
import itertools
import optparse

from ibm.teal import Teal
from ibm.teal import registry, alert
from ibm.teal.database import db_interface
from ibm.teal.util import command

def _gen_select_alerts(db, options, add_a2a_check):
    ''' Generate select to get the alerts (minus duplicates) that should be deleted '''
    
    where_flds = [alert.ALERT_ATTR_STATE, alert.ALERT_ATTR_REC_ID]  # init with columns always used 
    # Create where clause additions for options  
    if options.query_time is not None:
        older_where = "AND ${0} < '{1}'".format(alert.ALERT_ATTR_CREATION_TIME, options.query_time[0])
        where_flds.append(alert.ALERT_ATTR_CREATION_TIME)
    else:
        older_where = ''
        
    if options.recid_list is not None:
        recids_where = 'AND ${0} IN ({1})'.format(alert.ALERT_ATTR_REC_ID, options.recid_list)
        # rec_id field added in main clause below
    else:
        recids_where = ''

    if add_a2a_check == True:
        where_flds.append(alert.ALERT2ALERT_ATTR_T_ALERT_RECID)
        # Create select to embed in where that excludes duplicate alerts
        a2a_qry = db.gen_select([alert.ALERT2ALERT_ATTR_T_ALERT_RECID],
                                  db_interface.TABLE_ALERT2ALERT, 
                                  where="${0} = '{1}'".format(alert.ALERT2ALERT_ATTR_ASSOC_TYPE, alert.ALERT2ALERT_ASSOC_TYPE_DUPLICATE),
                                  where_fields=[alert.ALERT2ALERT_ATTR_ASSOC_TYPE])
        a2a_where = 'AND ${0} NOT IN ({1})'.format (alert.ALERT_ATTR_REC_ID, a2a_qry)
    else:
        a2a_where = ''

    out_select = db.gen_select([alert.ALERT_ATTR_REC_ID], db_interface.TABLE_ALERT_LOG, 
              where='${0} = {1} {2} {3} {4}'.format(alert.ALERT_ATTR_STATE,
                                                alert.ALERT_STATE_CLOSED,
                                                a2a_where,
                                                older_where,
                                                recids_where), 
              where_fields=where_flds)
    return out_select


if __name__ == '__main__':

    # Parse the command line        
    parser = optparse.OptionParser()
    parser.add_option('-i', '--ids',
                      type='string',
                      action='callback',
                      callback=command.opt_validate_type,
                      callback_args=(command.FIELD_TYPE_INT, True), # Integer List
                      dest='recid_list',
                      default=None,
                      help=_('A single alert id or a comma-separated list of alert ids'))
    parser.add_option('-o', '--older-than',
                      type='string',
                      action='callback',
                      callback=command.opt_validate_timestamp,
                      dest='query_time',
                      default=None,
                      help=_('The time condition_qry in the format YYYY-MM-DD-HH:MM::SS'))
    (options, args) = parser.parse_args()

    # Start up teal in data-only mode since we don't need the pipeline set up
    t = Teal(None, logFile='$TEAL_LOG_DIR/tlrmalert.log', msgLevel='warning', data_only=True)

    # Prepare to use the database
    db = registry.get_service(registry.SERVICE_DB_INTERFACE)
    cnxn = db.get_connection()
    cursor = cnxn.cursor()
    
    # Build the core alert where clause
    ## Always check state
    base_where_flds = [alert.ALERT_ATTR_STATE]
    base_where = '${0} = {1}'.format(alert.ALERT_ATTR_STATE, alert.ALERT_STATE_CLOSED)
    
    ### if option for time set add it 
    if options.query_time is not None:
        base_where = "{0} AND ${1} < '{2}'".format(base_where, alert.ALERT_ATTR_CREATION_TIME, options.query_time[0])
        base_where_flds.append(alert.ALERT_ATTR_CREATION_TIME)
    else:
        older_where = ''
    ### list of alerts
    if options.recid_list is not None:
        base_where = '{0} AND ${1} IN ({2})'.format(base_where, alert.ALERT_ATTR_REC_ID, options.recid_list)
        base_where_flds.append(alert.ALERT_ATTR_REC_ID)
    else:
        recids_where = ''
   
    # Build the where clause to select the A2A duplicate entries to be removed 
    a2a_entry_where = "${0} IN ({1}) AND ${2} = '{3}'".format(alert.ALERT2ALERT_ATTR_ALERT_RECID, 
                                                            db.gen_select([alert.ALERT_ATTR_REC_ID], 
                                                                          db_interface.TABLE_ALERT_LOG, 
                                                                          where=base_where,
                                                                          where_fields=base_where_flds),
                                                            alert.ALERT2ALERT_ATTR_ASSOC_TYPE, 
                                                            alert.ALERT2ALERT_ASSOC_TYPE_DUPLICATE)
    a2a_entry_where_fields=[alert.ALERT2ALERT_ATTR_ALERT_RECID, alert.ALERT2ALERT_ATTR_ASSOC_TYPE]
   
    # Get the duplicate alert rec_ids for later deletion 
    db.select(cursor, [alert.ALERT2ALERT_ATTR_T_ALERT_RECID], db_interface.TABLE_ALERT2ALERT, where=a2a_entry_where, where_fields=a2a_entry_where_fields)
    rows = cursor.fetchall()
    if rows is not None and len(rows) > 0:
        dups_to_delete = ','.join(str(row[0]) for row in rows)
    else:
        dups_to_delete = ''
        
    # Delete the duplicate associations 
    #    Where the source of the alert2alert entry is in the list of alerts to delete and it is a duplicate relationship
    db.delete(cursor, db_interface.TABLE_ALERT2ALERT, where=a2a_entry_where, where_fields=a2a_entry_where_fields)
    
    # Delete duplicate alerts 
    if dups_to_delete != '':
        db.delete(cursor, db_interface.TABLE_ALERT_LOG, 
                  where='${0} IN ({1})'.format(alert.ALERT_ATTR_REC_ID, dups_to_delete),
                  where_fields=[alert.ALERT_ATTR_REC_ID])
  
    # Delete base alerts
    #  where the alert is not the target of a duplicate relationship
    ## Get the rec_ids of the alerts that are the target of a duplicate relationship 
    ## Generate select of duplicate relationships in Alert2Alert table 
    a2a_qry = db.gen_select([alert.ALERT2ALERT_ATTR_T_ALERT_RECID],
                            db_interface.TABLE_ALERT2ALERT, 
                            where="${0} = '{1}'".format(alert.ALERT2ALERT_ATTR_ASSOC_TYPE, alert.ALERT2ALERT_ASSOC_TYPE_DUPLICATE),
                            where_fields=[alert.ALERT2ALERT_ATTR_ASSOC_TYPE])
    a2a_where = 'AND ${0} IN ({1})'.format (alert.ALERT_ATTR_REC_ID, a2a_qry)
    a2a_where_flds = base_where_flds + [alert.ALERT2ALERT_ATTR_ASSOC_TYPE, alert.ALERT_ATTR_REC_ID]
    db.select(cursor, [alert.ALERT_ATTR_REC_ID], db_interface.TABLE_ALERT_LOG, 
              where='{0} {1}'.format(base_where, a2a_where),
              where_fields=a2a_where_flds)
    rows = cursor.fetchall()
    if rows is not None and len(rows) > 0:
        dups_ignore_where = 'AND ${0} NOT IN ({1})'.format (alert.ALERT_ATTR_REC_ID, ','.join([str(row[0]) for row in rows]))
    else:
        dups_ignore_where = ''
   
    db.delete(cursor, db_interface.TABLE_ALERT_LOG, 
              where='{0} {1}'.format(base_where, dups_ignore_where),
              where_fields=base_where_flds)
    unique_alerts_deleted = cursor.rowcount
    
    cnxn.commit()

    # If record ids where specified, then if any of them were not deleted, let the user know why
    if options.recid_list is not None:
        alert_state_qry = db.gen_select([alert.ALERT_ATTR_REC_ID, alert.ALERT_ATTR_STATE],
                                        db_interface.TABLE_ALERT_LOG,
                                        where='${0} IN ({1})'.format(alert.ALERT_ATTR_REC_ID, options.recid_list),
                                        where_fields=[alert.ALERT_ATTR_REC_ID],
                                        order=alert.ALERT_ATTR_REC_ID)
        
        alert_assoc_qry = db.gen_select([alert.ALERT2ALERT_ATTR_ALERT_RECID, 
                                         alert.ALERT2ALERT_ATTR_ASSOC_TYPE,
                                         alert.ALERT2ALERT_ATTR_T_ALERT_RECID],
                                         db_interface.TABLE_ALERT2ALERT,
                                         where='${0} IN ({1})'.format(alert.ALERT2ALERT_ATTR_T_ALERT_RECID, options.recid_list),
                                         where_fields=[alert.ALERT2ALERT_ATTR_T_ALERT_RECID])
        
        cursor.execute(alert_state_qry)
        alert_states = cursor.fetchall()
        
        cursor.execute(alert_assoc_qry)
        alert_assocs = cursor.fetchall()
        
        for alert_recid, alert_state in alert_states:            
            print >>sys.stderr, _("Alert '{0}' cannot be removed.").format(alert_recid)
            
            # The Alert at least has to be closed
            if alert_state != alert.ALERT_STATE_CLOSED:
                print >>sys.stderr, '\tReason: Alert is not closed'
            
            # And it may have other active associations with other Alerts
            for assoc in itertools.ifilter(lambda x: x[2] == alert_recid, alert_assocs):                
                print >>sys.stderr, "\tReason: Alert is associated with Alert '{0}'".format(assoc[0])

    # All done, now shut down TEAL gracefully
    t.shutdown()

    if unique_alerts_deleted == 1:
        print _('\n{0} unique alert removed').format(unique_alerts_deleted)
    else:
        print _('\n{0} unique alerts removed').format(unique_alerts_deleted)
